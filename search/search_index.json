{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Simulaci\u00f3n \u00b6 Este es un curso de simulaci\u00f3n orientado a la simulaci\u00f3n de eventos discretos, y con un peque\u00f1o componente de din\u00e1mica de sistemas aplicado a modelos econ\u00f3micos. Objetivos \u00b6 Al finalizar el curso el estudiante debe ser capaz de: Explicar los conceptos fundamentales de las cadenas de markov Analizar las probabilidades de estado estable en cadenas erg\u00f3dicas Analizar las cadenas con estados absorbentes. Explicar el papel de las distribuciones de Poisson y Exponencial en relaci\u00f3n a los procesos de colas. Distinguir entre los procesos de colas fundamentales, desarrollar sus ecuaciones y aplicarlas. Explicar los elementos b\u00e1sicos de un problema de inventario Generar soluciones para modelos de inventarios simples tanto determin\u00edsticos como probabil\u00edsticos. Explicar la generaci\u00f3n de n\u00fameros pseudoaleatorios y su aplicaci\u00f3n en la generaci\u00f3n de observaciones aleatorias. Aplicar modelos de simulaci\u00f3n sencillos a problemas de decisi\u00f3n econ\u00f3mica. Contenido \u00b6 Simulaci\u00f3n de Monte Carlo y Riesgo An\u00e1lisis de riesgo en decisiones de negocio Simulaci\u00f3n de observaciones aleatorias An\u00e1lisis estad\u00edstico de modelos de simulaci\u00f3n Remuestreo de datos hist\u00f3ricos Correlaci\u00f3n de variables inciertas Simulaci\u00f3n de Eventos Discretos Conceptos b\u00e1sicos Algoritmo de simulaci\u00f3n de eventos discretos Uso de un lenguaje de simulaci\u00f3n An\u00e1lisis de las variables de entrada Distribuciones de uso com\u00fan Ajuste de par\u00e1metros Pruebas estad\u00edsticas An\u00e1lisis de las salidas M\u00e9todos tradicionales An\u00e1lisis de escenarios \u00d3ptimizaci\u00f3n basada en simulaci\u00f3n Enfoque de ense\u00f1anza \u00b6 El enfoque del curso es a trav\u00e9s de la programaci\u00f3n en Python, y la evaluaci\u00f3n es mediante la elaboraci\u00f3n de an\u00e1lisis sobre casos de estudio. En principio, uno por cada una de las unidades del contenido. Hay cuatro temas cada uno equivale al 25% de la calificaci\u00f3n definitiva. Bibliograf\u00eda \u00b6 J. R. Evans, Business analytics: methods, models, and decisions, Second edition, Global edition. Boston: Pearson, 2017. Y. E. Osais, Computer simulation: a foundational approach using Python. Boca Raton: CRC Press/Taylor & Francis Group, 2018. G. A. Wainer, Discrete-event modeling and simulation: a practitioner\u2019s approach. Boca Raton: CRC Press, 2009. A. B. Downey, Modeling and Simulation in Python. Version 3.4.3. Needham, Massachusetts: Green Tea Press, 2019. S. Robinson, Simulation: the practice of model development and use. Chichester, West Sussex, England\u202f; Hoboken, NJ: John Wiley & Sons, Ltd, 2004.","title":"Simulaci\u00f3n"},{"location":"index.html#simulacion","text":"Este es un curso de simulaci\u00f3n orientado a la simulaci\u00f3n de eventos discretos, y con un peque\u00f1o componente de din\u00e1mica de sistemas aplicado a modelos econ\u00f3micos.","title":"Simulaci\u00f3n"},{"location":"index.html#objetivos","text":"Al finalizar el curso el estudiante debe ser capaz de: Explicar los conceptos fundamentales de las cadenas de markov Analizar las probabilidades de estado estable en cadenas erg\u00f3dicas Analizar las cadenas con estados absorbentes. Explicar el papel de las distribuciones de Poisson y Exponencial en relaci\u00f3n a los procesos de colas. Distinguir entre los procesos de colas fundamentales, desarrollar sus ecuaciones y aplicarlas. Explicar los elementos b\u00e1sicos de un problema de inventario Generar soluciones para modelos de inventarios simples tanto determin\u00edsticos como probabil\u00edsticos. Explicar la generaci\u00f3n de n\u00fameros pseudoaleatorios y su aplicaci\u00f3n en la generaci\u00f3n de observaciones aleatorias. Aplicar modelos de simulaci\u00f3n sencillos a problemas de decisi\u00f3n econ\u00f3mica.","title":"Objetivos"},{"location":"index.html#contenido","text":"Simulaci\u00f3n de Monte Carlo y Riesgo An\u00e1lisis de riesgo en decisiones de negocio Simulaci\u00f3n de observaciones aleatorias An\u00e1lisis estad\u00edstico de modelos de simulaci\u00f3n Remuestreo de datos hist\u00f3ricos Correlaci\u00f3n de variables inciertas Simulaci\u00f3n de Eventos Discretos Conceptos b\u00e1sicos Algoritmo de simulaci\u00f3n de eventos discretos Uso de un lenguaje de simulaci\u00f3n An\u00e1lisis de las variables de entrada Distribuciones de uso com\u00fan Ajuste de par\u00e1metros Pruebas estad\u00edsticas An\u00e1lisis de las salidas M\u00e9todos tradicionales An\u00e1lisis de escenarios \u00d3ptimizaci\u00f3n basada en simulaci\u00f3n","title":"Contenido"},{"location":"index.html#enfoque-de-ensenanza","text":"El enfoque del curso es a trav\u00e9s de la programaci\u00f3n en Python, y la evaluaci\u00f3n es mediante la elaboraci\u00f3n de an\u00e1lisis sobre casos de estudio. En principio, uno por cada una de las unidades del contenido. Hay cuatro temas cada uno equivale al 25% de la calificaci\u00f3n definitiva.","title":"Enfoque de ense\u00f1anza"},{"location":"index.html#bibliografia","text":"J. R. Evans, Business analytics: methods, models, and decisions, Second edition, Global edition. Boston: Pearson, 2017. Y. E. Osais, Computer simulation: a foundational approach using Python. Boca Raton: CRC Press/Taylor & Francis Group, 2018. G. A. Wainer, Discrete-event modeling and simulation: a practitioner\u2019s approach. Boca Raton: CRC Press, 2009. A. B. Downey, Modeling and Simulation in Python. Version 3.4.3. Needham, Massachusetts: Green Tea Press, 2019. S. Robinson, Simulation: the practice of model development and use. Chichester, West Sussex, England\u202f; Hoboken, NJ: John Wiley & Sons, Ltd, 2004.","title":"Bibliograf\u00eda"},{"location":"01simulacion_riesgo.html","text":"Simulaci\u00f3n y Riesgo \u00b6 Con frecuencia se requiere incorporarla aleatoriedad de forma expl\u00edcita en los modelos predictivos. Esto se realiza esspecificando distribuciones de probabilidad para las variables de entrada no controlables. Los modelos con estos elementos se denominan estoc\u00e1sticos o probabil\u00edsticos y pueden ayudar a evaluar los riessgos asociados a consecuencias incontrolables, y permiten encontrar soluciones \u00f3ptimas bajo incertidumbre. Riesgo es la probabilidad de que ocurra un resultado no deseado, y puede ser evaluado a partir de su probabilidad y la gravedad del resultado. El an\u00e1lisis de riesgo consiste en el desarrollo de una comprensi\u00f3n y una conciencia completas del riesgo asociado con una variable de inter\u00e9s particular. Modelo de decisi\u00f3n de tercerizaci\u00f3n \u00b6 Se quiere decidir que es m\u00e1s conveniente, si fabricar un art\u00edculo, o adquirirlo hecho. Debido al costo fijo, si la demanda es peque\u00f1a vale m\u00e1s la pena comprar los productos de un proveedor, a medida que aumenta la demanda llega un punto en que es m\u00e1s conveniente fabricar los productos. Se asume que el volumen de producci\u00f3n es incierto, y que la demanda es una variable aleatoria con distribuci\u00f3n de probabilidad normal con \\mu = 1000 \\mu = 1000 y \\sigma = 10 \\sigma = 10 . Simulaci\u00f3n Puntual \u00b6 Vamos a realizar una simulaci\u00f3n para un \u00fanico valor (aleatorio) de la demanda. import random costo_fijo = 50000 costo_variable = 125 volumen_produccion = random . normalvariate ( mu = 1000 , sigma = 100 ) costo_manufactura = costo_fijo + costo_variable * volumen_produccion print ( f \"Costo Manufactura = {costo_manufactura:.2f}\" ) Costo Manufactura = 195041 . 72 costo_proveedor = 175 costo_compra = costo_proveedor * volumen_produccion print ( f \"Costo Compra = {costo_compra:.2f}\" ) Costo Compra = 203058 . 41 diferencia_costo = costo_manufactura - costo_compra print ( 'Comprar' if diferencia_costo > 0 else 'Fabricar' ) Fabricar El punto de equilibrio, es decir, la producci\u00f3n para la que el costo de manufactura y el costo de compra se igualen, ser\u00eda: \\begin{equation*} K + c_v \\times p = c_p \\times p \\\\ p = \\frac{K}{c_p - c_v} \\end{equation*} \\begin{equation*} K + c_v \\times p = c_p \\times p \\\\ p = \\frac{K}{c_p - c_v} \\end{equation*} equilibrio = costo_fijo / ( costo_proveedor - costo_variable ) print ( f \"Punto de Equilibrio = {equilibrio:.2f}\" ) Punto de Equilibrio = 1000 . 00 Como buen ejemplo de libro, el punto de equilibrio coincide con la media de la demanda. Generar una tabla de datos con la simulaci\u00f3n \u00b6 En el caso anterior, obtuvimos el valor para un caso particular. Pero, necesitamos realizar un n\u00famero de intentos significativos para poder analizar estad\u00edsticamente este modelo. Con esta finalidad generamos un conjunto de valores aleatorios de la demanda, y a partir de esta se construye una tabla que nos muestre los resultados de la simulaci\u00f3n. import pandas as pd import numpy as np import matplotlib.pyplot as plt demanda = np . random . normal ( loc = 1000 , scale = 100 , size = 20 ) demanda array ([ 1028 . 38624878 , 831 . 05960971 , 999 . 88696172 , 1028 . 65595162 , 1038 . 14048292 , 984 . 15659527 , 981 . 01701455 , 1001 . 38730974 , 1103 . 19115692 , 936 . 09733487 , 951 . 12325441 , 1045 . 4618419 , 1130 . 66557382 , 951 . 36180987 , 846 . 61063894 , 880 . 40833063 , 958 . 74859033 , 943 . 10191982 , 1022 . 58221132 , 837 . 50537013 ]) dif_costo = costo_fijo + ( costo_variable - costo_proveedor ) * demanda dif_costo array ([ - 1 . 41931244 e + 03 , 8 . 44701951 e + 03 , 5 . 65191413 e + 00 , - 1 . 43279758 e + 03 , - 1 . 90702415 e + 03 , 7 . 92170237 e + 02 , 9 . 49149273 e + 02 , - 6 . 93654872 e + 01 , - 5 . 15955785 e + 03 , 3 . 19513326 e + 03 , 2 . 44383728 e + 03 , - 2 . 27309210 e + 03 , - 6 . 53327869 e + 03 , 2 . 43190951 e + 03 , 7 . 66946805 e + 03 , 5 . 97958347 e + 03 , 2 . 06257048 e + 03 , 2 . 84490401 e + 03 , - 1 . 12911057 e + 03 , 8 . 12473149 e + 03 ]) decision = np . where ( dif_costo > 0 , 'Comprar' , 'Fabricar' ) decision array ([ 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Comprar' ], dtype = '<U8' ) tabla = pd . DataFrame ({ 'demanda' : demanda , 'diferencia' : dif_costo , 'decision' : decision }) tabla .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } demanda diferencia decision 0 1028.386249 -1419.312439 Fabricar 1 831.059610 8447.019514 Comprar 2 999.886962 5.651914 Comprar 3 1028.655952 -1432.797581 Fabricar 4 1038.140483 -1907.024146 Fabricar 5 984.156595 792.170237 Comprar 6 981.017015 949.149273 Comprar 7 1001.387310 -69.365487 Fabricar 8 1103.191157 -5159.557846 Fabricar 9 936.097335 3195.133256 Comprar 10 951.123254 2443.837280 Comprar 11 1045.461842 -2273.092095 Fabricar 12 1130.665574 -6533.278691 Fabricar 13 951.361810 2431.909507 Comprar 14 846.610639 7669.468053 Comprar 15 880.408331 5979.583468 Comprar 16 958.748590 2062.570484 Comprar 17 943.101920 2844.904009 Comprar 18 1022.582211 -1129.110566 Fabricar 19 837.505370 8124.731494 Comprar tabla . diferencia . hist () < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b9aa97b8 > La gran ventaja de utilizar un DataFrame en lugar de una hoja de c\u00e1lculo es que podemos realizar sin problema simulaciones para un gran n\u00famero de intentos. Incluso varias simulaciones. demanda = np . random . normal ( loc = 1000 , scale = 100 , size = 20000 ) dif_costo = costo_fijo + ( costo_variable - costo_proveedor ) * demanda decision = np . where ( dif_costo > 0 , 'Comprar' , 'Fabricar' ) tabla = pd . DataFrame ({ 'demanda' : demanda , 'diferencia' : dif_costo , 'decision' : decision }) tabla . diferencia . hist ( bins = 25 , grid = False , figsize = ( 8 , 6 ), color = '#86bf91' , zorder = 2 , rwidth = 0.9 ) < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b787ad68 > Como era de esperarse, como la diferencia es normal ya que se obtiene de una combinaci\u00f3n lineal de la demanda que es normal. tabla . decision . value_counts () Fabricar 10089 Comprar 9911 Name : decision , dtype : int64 tabla . decision . value_counts () . plot ( kind = 'bar' ) < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b7790e80 >","title":"Simulaci\u00f3n y Riesgo"},{"location":"01simulacion_riesgo.html#simulacion-y-riesgo","text":"Con frecuencia se requiere incorporarla aleatoriedad de forma expl\u00edcita en los modelos predictivos. Esto se realiza esspecificando distribuciones de probabilidad para las variables de entrada no controlables. Los modelos con estos elementos se denominan estoc\u00e1sticos o probabil\u00edsticos y pueden ayudar a evaluar los riessgos asociados a consecuencias incontrolables, y permiten encontrar soluciones \u00f3ptimas bajo incertidumbre. Riesgo es la probabilidad de que ocurra un resultado no deseado, y puede ser evaluado a partir de su probabilidad y la gravedad del resultado. El an\u00e1lisis de riesgo consiste en el desarrollo de una comprensi\u00f3n y una conciencia completas del riesgo asociado con una variable de inter\u00e9s particular.","title":"Simulaci\u00f3n y Riesgo"},{"location":"01simulacion_riesgo.html#modelo-de-decision-de-tercerizacion","text":"Se quiere decidir que es m\u00e1s conveniente, si fabricar un art\u00edculo, o adquirirlo hecho. Debido al costo fijo, si la demanda es peque\u00f1a vale m\u00e1s la pena comprar los productos de un proveedor, a medida que aumenta la demanda llega un punto en que es m\u00e1s conveniente fabricar los productos. Se asume que el volumen de producci\u00f3n es incierto, y que la demanda es una variable aleatoria con distribuci\u00f3n de probabilidad normal con \\mu = 1000 \\mu = 1000 y \\sigma = 10 \\sigma = 10 .","title":"Modelo de decisi\u00f3n de tercerizaci\u00f3n"},{"location":"01simulacion_riesgo.html#simulacion-puntual","text":"Vamos a realizar una simulaci\u00f3n para un \u00fanico valor (aleatorio) de la demanda. import random costo_fijo = 50000 costo_variable = 125 volumen_produccion = random . normalvariate ( mu = 1000 , sigma = 100 ) costo_manufactura = costo_fijo + costo_variable * volumen_produccion print ( f \"Costo Manufactura = {costo_manufactura:.2f}\" ) Costo Manufactura = 195041 . 72 costo_proveedor = 175 costo_compra = costo_proveedor * volumen_produccion print ( f \"Costo Compra = {costo_compra:.2f}\" ) Costo Compra = 203058 . 41 diferencia_costo = costo_manufactura - costo_compra print ( 'Comprar' if diferencia_costo > 0 else 'Fabricar' ) Fabricar El punto de equilibrio, es decir, la producci\u00f3n para la que el costo de manufactura y el costo de compra se igualen, ser\u00eda: \\begin{equation*} K + c_v \\times p = c_p \\times p \\\\ p = \\frac{K}{c_p - c_v} \\end{equation*} \\begin{equation*} K + c_v \\times p = c_p \\times p \\\\ p = \\frac{K}{c_p - c_v} \\end{equation*} equilibrio = costo_fijo / ( costo_proveedor - costo_variable ) print ( f \"Punto de Equilibrio = {equilibrio:.2f}\" ) Punto de Equilibrio = 1000 . 00 Como buen ejemplo de libro, el punto de equilibrio coincide con la media de la demanda.","title":"Simulaci\u00f3n Puntual"},{"location":"01simulacion_riesgo.html#generar-una-tabla-de-datos-con-la-simulacion","text":"En el caso anterior, obtuvimos el valor para un caso particular. Pero, necesitamos realizar un n\u00famero de intentos significativos para poder analizar estad\u00edsticamente este modelo. Con esta finalidad generamos un conjunto de valores aleatorios de la demanda, y a partir de esta se construye una tabla que nos muestre los resultados de la simulaci\u00f3n. import pandas as pd import numpy as np import matplotlib.pyplot as plt demanda = np . random . normal ( loc = 1000 , scale = 100 , size = 20 ) demanda array ([ 1028 . 38624878 , 831 . 05960971 , 999 . 88696172 , 1028 . 65595162 , 1038 . 14048292 , 984 . 15659527 , 981 . 01701455 , 1001 . 38730974 , 1103 . 19115692 , 936 . 09733487 , 951 . 12325441 , 1045 . 4618419 , 1130 . 66557382 , 951 . 36180987 , 846 . 61063894 , 880 . 40833063 , 958 . 74859033 , 943 . 10191982 , 1022 . 58221132 , 837 . 50537013 ]) dif_costo = costo_fijo + ( costo_variable - costo_proveedor ) * demanda dif_costo array ([ - 1 . 41931244 e + 03 , 8 . 44701951 e + 03 , 5 . 65191413 e + 00 , - 1 . 43279758 e + 03 , - 1 . 90702415 e + 03 , 7 . 92170237 e + 02 , 9 . 49149273 e + 02 , - 6 . 93654872 e + 01 , - 5 . 15955785 e + 03 , 3 . 19513326 e + 03 , 2 . 44383728 e + 03 , - 2 . 27309210 e + 03 , - 6 . 53327869 e + 03 , 2 . 43190951 e + 03 , 7 . 66946805 e + 03 , 5 . 97958347 e + 03 , 2 . 06257048 e + 03 , 2 . 84490401 e + 03 , - 1 . 12911057 e + 03 , 8 . 12473149 e + 03 ]) decision = np . where ( dif_costo > 0 , 'Comprar' , 'Fabricar' ) decision array ([ 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Fabricar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Comprar' , 'Fabricar' , 'Comprar' ], dtype = '<U8' ) tabla = pd . DataFrame ({ 'demanda' : demanda , 'diferencia' : dif_costo , 'decision' : decision }) tabla .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } demanda diferencia decision 0 1028.386249 -1419.312439 Fabricar 1 831.059610 8447.019514 Comprar 2 999.886962 5.651914 Comprar 3 1028.655952 -1432.797581 Fabricar 4 1038.140483 -1907.024146 Fabricar 5 984.156595 792.170237 Comprar 6 981.017015 949.149273 Comprar 7 1001.387310 -69.365487 Fabricar 8 1103.191157 -5159.557846 Fabricar 9 936.097335 3195.133256 Comprar 10 951.123254 2443.837280 Comprar 11 1045.461842 -2273.092095 Fabricar 12 1130.665574 -6533.278691 Fabricar 13 951.361810 2431.909507 Comprar 14 846.610639 7669.468053 Comprar 15 880.408331 5979.583468 Comprar 16 958.748590 2062.570484 Comprar 17 943.101920 2844.904009 Comprar 18 1022.582211 -1129.110566 Fabricar 19 837.505370 8124.731494 Comprar tabla . diferencia . hist () < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b9aa97b8 > La gran ventaja de utilizar un DataFrame en lugar de una hoja de c\u00e1lculo es que podemos realizar sin problema simulaciones para un gran n\u00famero de intentos. Incluso varias simulaciones. demanda = np . random . normal ( loc = 1000 , scale = 100 , size = 20000 ) dif_costo = costo_fijo + ( costo_variable - costo_proveedor ) * demanda decision = np . where ( dif_costo > 0 , 'Comprar' , 'Fabricar' ) tabla = pd . DataFrame ({ 'demanda' : demanda , 'diferencia' : dif_costo , 'decision' : decision }) tabla . diferencia . hist ( bins = 25 , grid = False , figsize = ( 8 , 6 ), color = '#86bf91' , zorder = 2 , rwidth = 0.9 ) < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b787ad68 > Como era de esperarse, como la diferencia es normal ya que se obtiene de una combinaci\u00f3n lineal de la demanda que es normal. tabla . decision . value_counts () Fabricar 10089 Comprar 9911 Name : decision , dtype : int64 tabla . decision . value_counts () . plot ( kind = 'bar' ) < matplotlib . axes . _subplots . AxesSubplot at 0 x7fa4b7790e80 >","title":"Generar una tabla de datos con la simulaci\u00f3n"},{"location":"02emulacion_risk.html","text":"Emulaci\u00f3n de una herramienta de An\u00e1lisis de Riesgo basada en Excel con Python \u00b6 Existen en Excel una variedad de herramientas para el an\u00e1lisis de riesgo, fundamentalmente utilizando modelado probabil\u00edstico de Monte Carlo. De esta manera, es posible introducir incertidumbre en los modelos de decisi\u00f3n y analizar el impacto de esta incertidumbre. A continuaci\u00f3n, para trazar un paralelo entre las herramientas de an\u00e1lisis de riesgo mediante simulaci\u00f3n de Monte Carlo y el an\u00e1lisis estad\u00edstico con Python se tomar\u00e1 como base un ejemplo que aparece en Business Analytics de James Evans del lanzamiento de un nuevo producto farmace\u00fatico. B\u00e1sicamente se trata de analizar la balanza de pagos entre la inversi\u00f3n inicial del producto y los beneficios netos producidos por las ventas en un horizonte de 5 a\u00f1os. Empezamos por importar los m\u00f3dulos necesarios. import numpy as np import matplotlib.pyplot as plt import pandas as pd from IPython.display import display , Markdown , Latex Datos \u00b6 Se introducen los datos del modelo, el tama\u00f1o base del mercado Market size , los ingresos mensuales unitarios Unit ( monthly Rx ) revenue , los costos mensuales unitarios Unit ( monthly Rx ) cost , y la tasa anual utilizada para los c\u00e1lculos financieros Discount rate . Para iniciar el proyecto es necesario realizar una inversi\u00f3n en investigaci\u00f3n y desarrollo R & D , y en ensayos cl\u00ednicos Clinical Trials , que sumados devuelven los costos totales del proyecto Total Project Costs . market_size = 2000000 unit_revenue = 130 unit_cost = 40 discount_rate = 0.09 rd_cost = 700000000 trials_cost = 150000000 total_costs = rd_cost + trials_cost Modelo Est\u00e1tico \u00b6 Ahora se procede a desarrollar el modelo, se proyecta que cada a\u00f1o el mercado crece de acuerdo al factor Market growth factor . Aunque esta es una operaci\u00f3n repetitiva es importante escribirla de forma vectorizada (evitando lazos de repetici\u00f3n) para sacar provecho de las bondades de numpy. As\u00ed, en lugar de: years = range ( 1 , 6 ) market_growth = np . empty ( 5 ) market_growth [ 0 ] = market_size growth_factor = 0.03 for i in range ( 1 , 5 ): market_growth [ i ] = market_growth [ i - 1 ] * ( growth_factor + 1 ) pd . DataFrame ({ 'Tama\u00f1o del mercado' : market_growth }, index = years ) . T . style . format ( '{:,.2f}' ) 1 2 3 4 5 Tama\u00f1o del mercado 2,000,000.00 2,060,000.00 2,121,800.00 2,185,454.00 2,251,017.62 Lo podemos expresar as\u00ed: growth_factor = np . append ( 0 , np . repeat ( 0.03 , 4 )) market_growth = market_size * ( growth_factor + 1 ) . cumprod () pd . DataFrame ({ 'Tama\u00f1o del mercado' : market_growth }, index = years ) . T . style . format ( '{:,.2f}' ) 1 2 3 4 5 Tama\u00f1o del mercado 2,000,000.00 2,060,000.00 2,121,800.00 2,185,454.00 2,251,017.62 De forma similar, la cuota de mercado crece anualmente de acuerdo a la tasa Market share growth rate . market_share = 0.08 share_growth_rate = np . append ( 0 , np . repeat ( 0.2 , 4 )) share_growth = market_share * ( share_growth_rate + 1 ) . cumprod () pd . DataFrame ({ 'Cuota del mercado' : share_growth }, index = years ) . T . style . format ( '{0:.0%}' ) 1 2 3 4 5 Cuota del mercado 8% 10% 12% 14% 17% Y as\u00ed, obtenemos las ventas (mensuales) como el producto de los dos vectores anteriores: sales = market_growth * share_growth pd . DataFrame ({ 'Ventas mensuales' : sales }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Ventas mensuales $160,000.00 $197,760.00 $244,431.36 $302,117.16 $373,416.81 Los ingresos anuales Annual Revenue se obtienen de la ventas mensuales por el precio de venta (multiplicado por 12), y los costos Annual Costs se calculan de las ventas por los costos unitarios. As\u00ed, el beneficio anual Profit se obtiene de la resta de cada uno de los valores anteriores para cada a\u00f1o. annual_revenue = sales * unit_revenue * 12 annual_costs = sales * unit_cost * 12 profit = annual_revenue - annual_costs pd . DataFrame ({ 'Beneficio anual' : profit }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Beneficio anual $172,800,000.00 $213,580,800.00 $263,985,868.80 $326,286,533.84 $403,290,155.82 El beneficio neto acumulado lo podemos calcular como una suma acumulada a la que se le restan los costos de inversi\u00f3n totales. net_profit = profit . cumsum () - total_costs pd . DataFrame ({ 'Beneficio neto acumulado' : net_profit }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Beneficio neto acumulado $-677,200,000.00 $-463,619,200.00 $-199,633,331.20 $126,653,202.64 $529,943,358.46 Como se puede observar en este caso, a partir del 4to a\u00f1o el beneficio neto empieza a dar positivo, por lo que se ha recuperado la inversi\u00f3n. Finalmente, el valor presente de la inversi\u00f3n lo calculamos utilizando la funci\u00f3n correspondiente de numpy. net_pv = np . pv ( discount_rate , range ( 1 , 6 ), 0 , - profit ) . sum () - total_costs display ( Markdown ( f \"**Valor presente neto** : ${net_pv:,.2f}\" )) Valor presente neto : $185,404,859.91 Configurando las distribuciones para la simulaci\u00f3n \u00b6 El modelo anterior se puede considerar una fotograf\u00eda de la enorme cantidad de posibilidades que podr\u00edamos tener, muchos factores son aleatorios y se desean explorar los patrones que surgen cuando operan de manera conjunta. En el caso de este modelo se considera que los siguientes factores son aleatorios: * El tama\u00f1o del mercado est\u00e1 distribuido normal con \\mu = \\$2,000,000 \\mu = \\$2,000,000 y \\sigma = \\$400,000 \\sigma = \\$400,000 . * La inversi\u00f3n en investigaci\u00f3n y desarrollo es uniforme entre \\$600,000,000 \\$600,000,000 y \\$800,000,000 \\$800,000,000 . * La inversi\u00f3n en ensayos cl\u00ednicos es lognormal con \\mu = \\$150,000,000 \\mu = \\$150,000,000 y \\sigma = \\$30,000,000 \\sigma = \\$30,000,000 . * El factor de crecimiento del mercado es triangular con m\u00ednimo 2\\% 2\\% , m\u00e1ximo 6\\% 6\\% , y valor m\u00e1s probable 3\\% 3\\% . * la tasa de crecimiento de la cuota de mercado es triangular con m\u00ednimo 15\\% 15\\% , m\u00e1ximo 25\\% 25\\% , y valor m\u00e1s probable 20\\% 20\\% . Vamos a ver como simulamos estas distribuciones una a una. Para el caso del tama\u00f1o del mercado: market_size = np . random . normal ( 2000000 , 400000 , 10000 ) plt . hist ( market_size , bins = 25 ) plt . show () Para la inversi\u00f3n en investigaci\u00f3n y desarrollo: rd_cost = np . random . uniform ( 600000000 , 800000000 , 10000 ) plt . hist ( rd_cost , bins = 25 ) plt . show () En el caso de la lognormal hay una peque\u00f1a complicaci\u00f3n, porque en numpy la media y la desviaci\u00f3n est\u00e1ndar que recibe la funci\u00f3n como par\u00e1metros son de la distribuci\u00f3n normal interna o subyacente, mientras que los valores dados corresponden a la propia log-normal. As\u00ed, \\mu_L \\mu_L y \\sigma_L \\sigma_L son los valores dados de la lognormal, y \\mu_N \\mu_N y \\sigma_N \\sigma_N los de la distribuci\u00f3n normal que hay que introducir a la funci\u00f3n. \\begin{equation*} \\mu_L = \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) \\\\ \\sigma_L^2 = [\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2) \\tag{0} \\end{equation*} \\begin{equation*} \\mu_L = \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) \\\\ \\sigma_L^2 = [\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2) \\tag{0} \\end{equation*} Se necesitan expresar \\mu_N \\mu_N y \\sigma_N \\sigma_N en funci\u00f3n de \\mu_L \\mu_L y \\sigma_L \\sigma_L . Para lograr esto, aplicamos algoritmos a ambos lados de cada expresi\u00f3n: \\begin{equation*} ln(\\mu_L) = ln\\left(\\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right)\\right) \\\\ ln(\\mu_L) = \\mu_N+\\frac{\\sigma_N^2}{2} \\end{equation*} \\begin{equation*} ln(\\mu_L) = ln\\left(\\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right)\\right) \\\\ ln(\\mu_L) = \\mu_N+\\frac{\\sigma_N^2}{2} \\end{equation*} As\u00ed, \\begin{equation*} \\mu_N = ln(\\mu_L)-\\frac{\\sigma_N^2}{2} \\tag{1} \\end{equation*} \\begin{equation*} \\mu_N = ln(\\mu_L)-\\frac{\\sigma_N^2}{2} \\tag{1} \\end{equation*} y \\begin{equation*} ln\\left(\\sigma_L^2\\right) = ln\\left([\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)\\right) \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+ln\\left(\\exp(2\\mu_N+\\sigma_N^2)\\right) \\end{equation*} \\begin{equation*} ln\\left(\\sigma_L^2\\right) = ln\\left([\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)\\right) \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+ln\\left(\\exp(2\\mu_N+\\sigma_N^2)\\right) \\end{equation*} \\begin{equation*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2\\mu_N+\\sigma_N^2 \\tag{2} \\end{equation*} \\begin{equation*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2\\mu_N+\\sigma_N^2 \\tag{2} \\end{equation*} Sustituyendo (1) (1) en (2) (2) . \\begin{align*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2(ln(\\mu_L)-\\frac{\\sigma_N^2}{2})+\\sigma_N^2 \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2ln(\\mu_L)-\\sigma_N^2+\\sigma_N^2 \\end{align*} \\begin{align*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2(ln(\\mu_L)-\\frac{\\sigma_N^2}{2})+\\sigma_N^2 \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2ln(\\mu_L)-\\sigma_N^2+\\sigma_N^2 \\end{align*} Simplificando \\begin{equation*} ln\\left([\\exp(\\sigma_N^2)-1]\\right) = 2ln(\\sigma_L)-2ln(\\mu_L) \\\\ ln\\left([\\exp(\\sigma_N^2)-1]\\right) = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) \\\\ [\\exp(\\sigma_N^2)-1] = \\left(\\frac{\\sigma_L}{\\mu_L}\\right)^2 \\end{equation*} \\begin{equation*} ln\\left([\\exp(\\sigma_N^2)-1]\\right) = 2ln(\\sigma_L)-2ln(\\mu_L) \\\\ ln\\left([\\exp(\\sigma_N^2)-1]\\right) = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) \\\\ [\\exp(\\sigma_N^2)-1] = \\left(\\frac{\\sigma_L}{\\mu_L}\\right)^2 \\end{equation*} Nos queda entonces: \\begin{equation*} ln\\exp(\\sigma_N^2) = ln\\left(\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1\\right) \\\\ \\sigma_N^2 = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1 \\\\ \\end{equation*} \\begin{equation*} ln\\exp(\\sigma_N^2) = ln\\left(\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1\\right) \\\\ \\sigma_N^2 = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1 \\\\ \\end{equation*} \\begin{equation*} \\sigma_N = \\sqrt{1 + ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right)} \\tag{3} \\end{equation*} \\begin{equation*} \\sigma_N = \\sqrt{1 + ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right)} \\tag{3} \\end{equation*} De esta forma, hallamos \\sigma_N \\sigma_N usando (3) (3) , y con este valor encontramos \\mu_N \\mu_N usando (1) (1) , lo que en python se traduce en: from math import sqrt , log lognormal_mean = 150000000 lognormal_std = 30000000 normal_std = sqrt ( log ( 1 + ( lognormal_std / lognormal_mean ) ** 2 )) normal_mean = log ( lognormal_mean ) - normal_std ** 2 / 2 display ( Markdown ( f \"$\\mu_N$ = {normal_mean:.6f}, $\\sigma_N$ = {normal_std:.6f}\" )) \\mu_N \\mu_N = 18.806535, \\sigma_N \\sigma_N = 0.198042 El desarrollo de estas expresiones se hace con dos objetivos pedag\u00f3gicos: Dar un ejemplo de como escribir ecuaciones en formato \\LaTeX \\LaTeX y, Mostrar como es necesario de vez en cuando recurrir a las matem\u00e1ticas y la estad\u00edstica para utilizar adecuadamente las herramientas. M\u00e1s a\u00fan, igualando las ecuaciones (0) (0) a cero, \\begin{equation*} \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) - \\mu_L = 0 \\\\ \\sqrt{[\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)} - \\sigma_L = 0 \\end{equation*} \\begin{equation*} \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) - \\mu_L = 0 \\\\ \\sqrt{[\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)} - \\sigma_L = 0 \\end{equation*} podr\u00edamos haber obtenido los par\u00e1metros de la normal subyacente utilizando m\u00e9todos num\u00e9ricos como sigue: from math import exp , sqrt from scipy import optimize def fun ( x ): return [ exp ( x [ 0 ] + x [ 1 ] ** 2 / 2 ) - 150000000 , sqrt (( exp ( x [ 1 ] ** 2 ) - 1 ) * exp ( 2 * x [ 0 ] + x [ 1 ] ** 2 )) - 30000000 ] sol = optimize . root ( fun , [ 0 , 0 ], jac = False , method = 'lm' ) display ( Markdown ( f \"$\\mu_N$ = {sol.x[0]:.6f}, $\\sigma_N$ = {sol.x[1]:.6f}\" )) \\mu_N \\mu_N = 18.806535, \\sigma_N \\sigma_N = 0.198042 La simulaci\u00f3n de la distribuci\u00f3n queda como sigue, trials_cost = np . random . lognormal ( normal_mean , normal_std , 10000 ) plt . hist ( trials_cost , bins = 25 ) plt . show () N\u00f3tese en el gr\u00e1fico como la media de la distribuci\u00f3n se corresponde con los 150 millones. Para la simulaci\u00f3n de las distribuciones triangulares no tenemos mayor problema, esta ser\u00eda la simulaci\u00f3n del factor de crecimiento del mercado: growth_factor = np . random . triangular ( 0.02 , 0.03 , 0.06 , 10000 ) plt . hist ( growth_factor , bins = 25 ) plt . show () Y la tasa de crecimiento de la cuota de mercado, share_growth_rate = np . random . triangular ( 0.15 , 0.20 , 0.25 , 10000 ) plt . hist ( share_growth_rate , bins = 25 ) plt . show () Modelo de Simulaci\u00f3n \u00b6 Ahora tenemos que juntar todo lo anterior para generar un buen n\u00famero de replicas, digamos 10 mil, a partir de las observaciones aleatorias mencionadas arriba. En lo fundamental, se trata de re-escribir el m\u00e9todo est\u00e1tico sustituyendo las valores fijos por las respectivas distribuciones de probabilidad, teniendo cuidado de escribir las replicas utilizando la vectorizaci\u00f3n. Empezamos por la demanda inicial. market_size = np . random . normal ( 2000000 , 400000 , ( 10000 , 1 )) df_market_size = pd . DataFrame ( market_size , columns = [ \"Mercado\" ]) fill = pd . DataFrame ([[ np . nan ]], columns = df_market_size . columns , index = [ - 1 ]) pd . concat ([ df_market_size . head (), fill , df_market_size . tail ()]) . style . format ( '{:,.2f}' ) Mercado 0 1,652,239.64 1 1,969,999.61 2 2,163,194.86 3 2,026,208.19 4 1,508,792.95 -1 nan 9995 2,186,960.44 9996 2,266,746.44 9997 1,612,958.28 9998 1,614,676.92 9999 2,318,227.67 N\u00f3tese la especificaci\u00f3n de la forma como un vector columna, esto es conveniente para las operaciones matriciales. Convertimos los datos a un DataFrame, al igual que arriba, solamente para que aparezca en un formato tabular. La inversi\u00f3n en investigaci\u00f3n y desarrollo ser\u00eda: rd_cost = np . random . uniform ( 600000000 , 800000000 , ( 10000 , 1 )) df_rd_cost = pd . DataFrame ( rd_cost , columns = [ \"I&D\" ]) df_rd_cost . head () . style . format ( '${:,.2f}' ) I&D 0 $789,017,336.24 1 $681,778,711.82 2 $609,999,767.67 3 $741,289,119.26 4 $778,498,962.07 Se utiliza el m\u00e9todo head para que devuelva solamente los primeros 5 valores de la tabla. La inversi\u00f3n en ensayos cl\u00ednicos: trials_cost = np . random . lognormal ( normal_mean , normal_std , ( 10000 , 1 )) df_trials_cost = pd . DataFrame ( trials_cost , columns = [ \"Trials\" ]) df_trials_cost . head () . style . format ( '${:,.2f}' ) Trials 0 $129,832,559.70 1 $155,901,122.92 2 $188,361,209.28 3 $122,215,935.09 4 $117,333,770.31 Para simular tanto el factor de crecimiento del mercado, como la tasa de crecimiento de la cuota de mercado, se deben simular cuatro valores para cada r\u00e9plica, y adem\u00e1s a\u00f1adir un cero inicial para realizar las operaciones vectorizadas. growth_factor = np . random . triangular ( 0.02 , 0.03 , 0.06 , ( 10000 , 4 )) growth_factor = np . hstack (( np . zeros (( 10000 , 1 )), growth_factor )) df_growth_factor = pd . DataFrame ( growth_factor , columns = [ \"f0\" , \"f1\" , \"f2\" , \"f3\" , \"f4\" ]) df_growth_factor . head () . style . format ( '{:.4%}' ) f0 f1 f2 f3 f4 0 0.0000% 2.4764% 3.1657% 3.5671% 3.2335% 1 0.0000% 3.2036% 3.1690% 3.8859% 2.6284% 2 0.0000% 2.9057% 4.9937% 3.1970% 2.5166% 3 0.0000% 3.9681% 2.7311% 2.6351% 5.7171% 4 0.0000% 3.3604% 3.7505% 2.6006% 4.0251% share_growth_rate = np . random . triangular ( 0.15 , 0.20 , 0.25 , ( 10000 , 4 )) share_growth_rate = np . hstack (( np . zeros (( 10000 , 1 )), share_growth_rate )) df_share_growth_rate = pd . DataFrame ( share_growth_rate , columns = [ \"t0\" , \"t1\" , \"t2\" , \"t3\" , \"t4\" ]) df_share_growth_rate . head () . style . format ( '{:.4%}' ) t0 t1 t2 t3 t4 0 0.0000% 20.6200% 23.3980% 22.2926% 21.0754% 1 0.0000% 17.9850% 22.0162% 20.2440% 19.9272% 2 0.0000% 20.1128% 19.4268% 19.5343% 20.7639% 3 0.0000% 20.2069% 18.5348% 18.6056% 21.9466% 4 0.0000% 21.0364% 19.1765% 21.9899% 19.9574% A continuaci\u00f3n, para calcular el crecimiento del mercado utilizando los factores de crecimiento reci\u00e9n generados, utilizamos la misma expresi\u00f3n indicada arriba con el detalle de a\u00f1adir el par\u00e1metro axis = 1 para realizar la multiplicaci\u00f3n fila por fila. market_growth = market_size * ( growth_factor + 1 ) . cumprod ( axis = 1 ) df_market_growth = pd . DataFrame ( market_growth , columns = [ \"M0\" , \"M1\" , \"M2\" , \"M3\" , \"M4\" ]) df_market_growth . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } M0 M1 M2 M3 M4 0 1.652240e+06 1.693156e+06 1.746757e+06 1.809065e+06 1.867560e+06 1 1.970000e+06 2.033111e+06 2.097540e+06 2.179049e+06 2.236324e+06 2 2.163195e+06 2.226050e+06 2.337212e+06 2.411933e+06 2.472632e+06 3 2.026208e+06 2.106610e+06 2.164143e+06 2.221170e+06 2.348157e+06 4 1.508793e+06 1.559495e+06 1.617983e+06 1.660061e+06 1.726880e+06 Para realizar la simulaci\u00f3n del crecimiento de la cuota de mercado creamos antes un vector columna con los valores de la cuota de mercado inicial. market_share = np . tile ( 0.08 , ( 10000 , 1 )) share_growth = market_share * ( share_growth_rate + 1 ) . cumprod ( axis = 1 ) df_share_growth = pd . DataFrame ( share_growth , columns = [ \"Q0\" , \"Q1\" , \"Q2\" , \"Q3\" , \"Q4\" ]) df_share_growth . head () . style . format ( '{:.4%}' ) Q0 Q1 Q2 Q3 Q4 0 8.0000% 9.6496% 11.9074% 14.5619% 17.6309% 1 8.0000% 9.4388% 11.5169% 13.8483% 16.6079% 2 8.0000% 9.6090% 11.4757% 13.7175% 16.5657% 3 8.0000% 9.6166% 11.3990% 13.5198% 16.4869% 4 8.0000% 9.6829% 11.5398% 14.0773% 16.8868% Los c\u00e1lculos de las ventas, ingresos, costos y beneficios se mantienen id\u00e9nticos: sales = market_growth * share_growth annual_revenue = sales * unit_revenue * 12 annual_costs = sales * unit_cost * 12 profit = annual_revenue - annual_costs total_costs = rd_cost + trials_cost df_sales = pd . DataFrame ( sales , columns = [ \"S0\" , \"S1\" , \"S2\" , \"S3\" , \"S4\" ]) df_sales . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } S0 S1 S2 S3 S4 0 132179.171553 163382.784721 207993.551040 263433.900357 329266.919016 1 157599.969101 191901.224300 241570.911766 301762.089695 371406.892945 2 173055.588797 213901.688289 268212.546825 330855.659805 409609.498834 3 162096.654800 202583.236053 246689.751191 300297.779327 387138.942603 4 120703.435851 151004.502944 186711.234225 233692.317113 291615.027497 df_annual_revenue = pd . DataFrame ( annual_revenue , columns = [ \"IA0\" , \"IA1\" , \"IA2\" , \"IA3\" , \"IA4\" ]) df_annual_revenue . head () . style . format ( '${:,.2f}' ) IA0 IA1 IA2 IA3 IA4 0 $206,199,507.62 $254,877,144.16 $324,469,939.62 $410,956,884.56 $513,656,393.66 1 $245,855,951.80 $299,365,909.91 $376,850,622.36 $470,748,859.92 $579,394,752.99 2 $269,966,718.52 $333,686,633.73 $418,411,573.05 $516,134,829.30 $638,990,818.18 3 $252,870,781.49 $316,029,848.24 $384,836,011.86 $468,464,535.75 $603,936,750.46 4 $188,297,359.93 $235,567,024.59 $291,269,525.39 $364,560,014.70 $454,919,442.90 df_annual_costs = pd . DataFrame ( annual_costs , columns = [ \"CA0\" , \"CA1\" , \"CA2\" , \"CA3\" , \"CA4\" ]) df_annual_costs . head () . style . format ( '${:,.2f}' ) CA0 CA1 CA2 CA3 CA4 0 $63,446,002.35 $78,423,736.67 $99,836,904.50 $126,448,272.17 $158,048,121.13 1 $75,647,985.17 $92,112,587.66 $115,954,037.65 $144,845,803.05 $178,275,308.61 2 $83,066,682.62 $102,672,810.38 $128,742,022.48 $158,810,716.71 $196,612,559.44 3 $77,806,394.30 $97,239,953.31 $118,411,080.57 $144,142,934.08 $185,826,692.45 4 $57,937,649.21 $72,482,161.41 $89,621,392.43 $112,172,312.21 $139,975,213.20 El c\u00e1lculo del beneficio neto acumulado solamente requiere de tener cuidado con que las operaciones sean por filas. net_profit = profit . cumsum ( axis = 1 ) - total_costs df_net_profit = pd . DataFrame ( net_profit , columns = [ \"BNA0\" , \"BNA1\" , \"BNA2\" , \"BNA3\" , \"BNA4\" ]) df_net_profit . head () . style . format ( '${:,.2f}' ) BNA0 BNA1 BNA2 BNA3 BNA4 0 $-776,096,390.66 $-599,642,983.16 $-375,009,948.04 $-90,501,335.65 $265,106,936.89 1 $-667,471,868.11 $-460,218,545.86 $-199,321,961.15 $126,581,095.72 $527,700,540.10 2 $-611,460,941.05 $-380,447,117.70 $-90,777,567.13 $266,546,545.46 $708,924,804.20 3 $-688,440,667.17 $-469,650,772.23 $-203,225,840.94 $121,095,760.73 $539,205,818.74 4 $-765,473,021.66 $-602,388,158.48 $-400,740,025.52 $-148,352,323.04 $166,591,906.66 Finalmente, el c\u00e1lculo del valor presente neto para todas las r\u00e9plicas aparte de realizar la suma por filas requiere que se mantengan las dimensiones keepdims = True porque la suma sobre los vectores por defecto aplana el resultado. net_pv = np . pv ( discount_rate , range ( 1 , 6 ), 0 , - profit ) . sum ( axis = 1 , keepdims = True ) - total_costs df_net_pv = pd . DataFrame ( net_pv , columns = [ \"VPneto\" ]) df_net_pv . head () . style . format ( '${:,.2f}' ) VPneto 0 $-33,234,104.37 1 $185,953,329.08 2 $331,877,625.65 3 $188,484,931.84 4 $-99,772,092.68 Ahora podemos tener la distribuci\u00f3n del valor presente neto del proyecto. plt . hist ( net_pv , bins = 25 ) plt . show () Se puede observar que si bien la media est\u00e1 alrededor de los 200 millones de d\u00f3lares existe la posibilidad de tener retornos negativos. Para calcular este porcentaje sacamos provecho que en Python un valor l\u00f3gico verdadero True es equivalente a 1 para las operaciones aritm\u00e9ticas. De esta manera, negative_risk = ( net_pv < 0 ) . mean () display ( Markdown ( f \"Riesgo de retornos negativos = {negative_risk:.2%}\" )) Riesgo de retornos negativos = 18.98% Nos quedan dos preguntas pendientes: * \u00bfCu\u00e1l es la probabilidad de obtener beneficios acumulados netos (positivos) para el tercer a\u00f1o? * \u00bfQu\u00e9 beneficio acumulado m\u00ednimo se obtendr\u00eda en el 5to a\u00f1o con una probabilidad de por lo menos el 90%? ( net_profit [:, 2 ] > 0 ) . mean () 0 . 0913 np . percentile ( net_profit [:, 4 ], 10 ) 175306982 . 56709474","title":"Emulaci\u00f3n de una herramienta de An\u00e1lisis de Riesgo basada en Excel con Python"},{"location":"02emulacion_risk.html#emulacion-de-una-herramienta-de-analisis-de-riesgo-basada-en-excel-con-python","text":"Existen en Excel una variedad de herramientas para el an\u00e1lisis de riesgo, fundamentalmente utilizando modelado probabil\u00edstico de Monte Carlo. De esta manera, es posible introducir incertidumbre en los modelos de decisi\u00f3n y analizar el impacto de esta incertidumbre. A continuaci\u00f3n, para trazar un paralelo entre las herramientas de an\u00e1lisis de riesgo mediante simulaci\u00f3n de Monte Carlo y el an\u00e1lisis estad\u00edstico con Python se tomar\u00e1 como base un ejemplo que aparece en Business Analytics de James Evans del lanzamiento de un nuevo producto farmace\u00fatico. B\u00e1sicamente se trata de analizar la balanza de pagos entre la inversi\u00f3n inicial del producto y los beneficios netos producidos por las ventas en un horizonte de 5 a\u00f1os. Empezamos por importar los m\u00f3dulos necesarios. import numpy as np import matplotlib.pyplot as plt import pandas as pd from IPython.display import display , Markdown , Latex","title":"Emulaci\u00f3n de una herramienta de An\u00e1lisis de Riesgo basada en Excel con Python"},{"location":"02emulacion_risk.html#datos","text":"Se introducen los datos del modelo, el tama\u00f1o base del mercado Market size , los ingresos mensuales unitarios Unit ( monthly Rx ) revenue , los costos mensuales unitarios Unit ( monthly Rx ) cost , y la tasa anual utilizada para los c\u00e1lculos financieros Discount rate . Para iniciar el proyecto es necesario realizar una inversi\u00f3n en investigaci\u00f3n y desarrollo R & D , y en ensayos cl\u00ednicos Clinical Trials , que sumados devuelven los costos totales del proyecto Total Project Costs . market_size = 2000000 unit_revenue = 130 unit_cost = 40 discount_rate = 0.09 rd_cost = 700000000 trials_cost = 150000000 total_costs = rd_cost + trials_cost","title":"Datos"},{"location":"02emulacion_risk.html#modelo-estatico","text":"Ahora se procede a desarrollar el modelo, se proyecta que cada a\u00f1o el mercado crece de acuerdo al factor Market growth factor . Aunque esta es una operaci\u00f3n repetitiva es importante escribirla de forma vectorizada (evitando lazos de repetici\u00f3n) para sacar provecho de las bondades de numpy. As\u00ed, en lugar de: years = range ( 1 , 6 ) market_growth = np . empty ( 5 ) market_growth [ 0 ] = market_size growth_factor = 0.03 for i in range ( 1 , 5 ): market_growth [ i ] = market_growth [ i - 1 ] * ( growth_factor + 1 ) pd . DataFrame ({ 'Tama\u00f1o del mercado' : market_growth }, index = years ) . T . style . format ( '{:,.2f}' ) 1 2 3 4 5 Tama\u00f1o del mercado 2,000,000.00 2,060,000.00 2,121,800.00 2,185,454.00 2,251,017.62 Lo podemos expresar as\u00ed: growth_factor = np . append ( 0 , np . repeat ( 0.03 , 4 )) market_growth = market_size * ( growth_factor + 1 ) . cumprod () pd . DataFrame ({ 'Tama\u00f1o del mercado' : market_growth }, index = years ) . T . style . format ( '{:,.2f}' ) 1 2 3 4 5 Tama\u00f1o del mercado 2,000,000.00 2,060,000.00 2,121,800.00 2,185,454.00 2,251,017.62 De forma similar, la cuota de mercado crece anualmente de acuerdo a la tasa Market share growth rate . market_share = 0.08 share_growth_rate = np . append ( 0 , np . repeat ( 0.2 , 4 )) share_growth = market_share * ( share_growth_rate + 1 ) . cumprod () pd . DataFrame ({ 'Cuota del mercado' : share_growth }, index = years ) . T . style . format ( '{0:.0%}' ) 1 2 3 4 5 Cuota del mercado 8% 10% 12% 14% 17% Y as\u00ed, obtenemos las ventas (mensuales) como el producto de los dos vectores anteriores: sales = market_growth * share_growth pd . DataFrame ({ 'Ventas mensuales' : sales }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Ventas mensuales $160,000.00 $197,760.00 $244,431.36 $302,117.16 $373,416.81 Los ingresos anuales Annual Revenue se obtienen de la ventas mensuales por el precio de venta (multiplicado por 12), y los costos Annual Costs se calculan de las ventas por los costos unitarios. As\u00ed, el beneficio anual Profit se obtiene de la resta de cada uno de los valores anteriores para cada a\u00f1o. annual_revenue = sales * unit_revenue * 12 annual_costs = sales * unit_cost * 12 profit = annual_revenue - annual_costs pd . DataFrame ({ 'Beneficio anual' : profit }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Beneficio anual $172,800,000.00 $213,580,800.00 $263,985,868.80 $326,286,533.84 $403,290,155.82 El beneficio neto acumulado lo podemos calcular como una suma acumulada a la que se le restan los costos de inversi\u00f3n totales. net_profit = profit . cumsum () - total_costs pd . DataFrame ({ 'Beneficio neto acumulado' : net_profit }, index = years ) . T . style . format ( '${:,.2f}' ) 1 2 3 4 5 Beneficio neto acumulado $-677,200,000.00 $-463,619,200.00 $-199,633,331.20 $126,653,202.64 $529,943,358.46 Como se puede observar en este caso, a partir del 4to a\u00f1o el beneficio neto empieza a dar positivo, por lo que se ha recuperado la inversi\u00f3n. Finalmente, el valor presente de la inversi\u00f3n lo calculamos utilizando la funci\u00f3n correspondiente de numpy. net_pv = np . pv ( discount_rate , range ( 1 , 6 ), 0 , - profit ) . sum () - total_costs display ( Markdown ( f \"**Valor presente neto** : ${net_pv:,.2f}\" )) Valor presente neto : $185,404,859.91","title":"Modelo Est\u00e1tico"},{"location":"02emulacion_risk.html#configurando-las-distribuciones-para-la-simulacion","text":"El modelo anterior se puede considerar una fotograf\u00eda de la enorme cantidad de posibilidades que podr\u00edamos tener, muchos factores son aleatorios y se desean explorar los patrones que surgen cuando operan de manera conjunta. En el caso de este modelo se considera que los siguientes factores son aleatorios: * El tama\u00f1o del mercado est\u00e1 distribuido normal con \\mu = \\$2,000,000 \\mu = \\$2,000,000 y \\sigma = \\$400,000 \\sigma = \\$400,000 . * La inversi\u00f3n en investigaci\u00f3n y desarrollo es uniforme entre \\$600,000,000 \\$600,000,000 y \\$800,000,000 \\$800,000,000 . * La inversi\u00f3n en ensayos cl\u00ednicos es lognormal con \\mu = \\$150,000,000 \\mu = \\$150,000,000 y \\sigma = \\$30,000,000 \\sigma = \\$30,000,000 . * El factor de crecimiento del mercado es triangular con m\u00ednimo 2\\% 2\\% , m\u00e1ximo 6\\% 6\\% , y valor m\u00e1s probable 3\\% 3\\% . * la tasa de crecimiento de la cuota de mercado es triangular con m\u00ednimo 15\\% 15\\% , m\u00e1ximo 25\\% 25\\% , y valor m\u00e1s probable 20\\% 20\\% . Vamos a ver como simulamos estas distribuciones una a una. Para el caso del tama\u00f1o del mercado: market_size = np . random . normal ( 2000000 , 400000 , 10000 ) plt . hist ( market_size , bins = 25 ) plt . show () Para la inversi\u00f3n en investigaci\u00f3n y desarrollo: rd_cost = np . random . uniform ( 600000000 , 800000000 , 10000 ) plt . hist ( rd_cost , bins = 25 ) plt . show () En el caso de la lognormal hay una peque\u00f1a complicaci\u00f3n, porque en numpy la media y la desviaci\u00f3n est\u00e1ndar que recibe la funci\u00f3n como par\u00e1metros son de la distribuci\u00f3n normal interna o subyacente, mientras que los valores dados corresponden a la propia log-normal. As\u00ed, \\mu_L \\mu_L y \\sigma_L \\sigma_L son los valores dados de la lognormal, y \\mu_N \\mu_N y \\sigma_N \\sigma_N los de la distribuci\u00f3n normal que hay que introducir a la funci\u00f3n. \\begin{equation*} \\mu_L = \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) \\\\ \\sigma_L^2 = [\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2) \\tag{0} \\end{equation*} \\begin{equation*} \\mu_L = \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) \\\\ \\sigma_L^2 = [\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2) \\tag{0} \\end{equation*} Se necesitan expresar \\mu_N \\mu_N y \\sigma_N \\sigma_N en funci\u00f3n de \\mu_L \\mu_L y \\sigma_L \\sigma_L . Para lograr esto, aplicamos algoritmos a ambos lados de cada expresi\u00f3n: \\begin{equation*} ln(\\mu_L) = ln\\left(\\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right)\\right) \\\\ ln(\\mu_L) = \\mu_N+\\frac{\\sigma_N^2}{2} \\end{equation*} \\begin{equation*} ln(\\mu_L) = ln\\left(\\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right)\\right) \\\\ ln(\\mu_L) = \\mu_N+\\frac{\\sigma_N^2}{2} \\end{equation*} As\u00ed, \\begin{equation*} \\mu_N = ln(\\mu_L)-\\frac{\\sigma_N^2}{2} \\tag{1} \\end{equation*} \\begin{equation*} \\mu_N = ln(\\mu_L)-\\frac{\\sigma_N^2}{2} \\tag{1} \\end{equation*} y \\begin{equation*} ln\\left(\\sigma_L^2\\right) = ln\\left([\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)\\right) \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+ln\\left(\\exp(2\\mu_N+\\sigma_N^2)\\right) \\end{equation*} \\begin{equation*} ln\\left(\\sigma_L^2\\right) = ln\\left([\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)\\right) \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+ln\\left(\\exp(2\\mu_N+\\sigma_N^2)\\right) \\end{equation*} \\begin{equation*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2\\mu_N+\\sigma_N^2 \\tag{2} \\end{equation*} \\begin{equation*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2\\mu_N+\\sigma_N^2 \\tag{2} \\end{equation*} Sustituyendo (1) (1) en (2) (2) . \\begin{align*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2(ln(\\mu_L)-\\frac{\\sigma_N^2}{2})+\\sigma_N^2 \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2ln(\\mu_L)-\\sigma_N^2+\\sigma_N^2 \\end{align*} \\begin{align*} 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2(ln(\\mu_L)-\\frac{\\sigma_N^2}{2})+\\sigma_N^2 \\\\ 2ln(\\sigma_L) = ln\\left([\\exp(\\sigma_N^2)-1]\\right)+2ln(\\mu_L)-\\sigma_N^2+\\sigma_N^2 \\end{align*} Simplificando \\begin{equation*} ln\\left([\\exp(\\sigma_N^2)-1]\\right) = 2ln(\\sigma_L)-2ln(\\mu_L) \\\\ ln\\left([\\exp(\\sigma_N^2)-1]\\right) = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) \\\\ [\\exp(\\sigma_N^2)-1] = \\left(\\frac{\\sigma_L}{\\mu_L}\\right)^2 \\end{equation*} \\begin{equation*} ln\\left([\\exp(\\sigma_N^2)-1]\\right) = 2ln(\\sigma_L)-2ln(\\mu_L) \\\\ ln\\left([\\exp(\\sigma_N^2)-1]\\right) = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) \\\\ [\\exp(\\sigma_N^2)-1] = \\left(\\frac{\\sigma_L}{\\mu_L}\\right)^2 \\end{equation*} Nos queda entonces: \\begin{equation*} ln\\exp(\\sigma_N^2) = ln\\left(\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1\\right) \\\\ \\sigma_N^2 = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1 \\\\ \\end{equation*} \\begin{equation*} ln\\exp(\\sigma_N^2) = ln\\left(\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1\\right) \\\\ \\sigma_N^2 = ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right) + 1 \\\\ \\end{equation*} \\begin{equation*} \\sigma_N = \\sqrt{1 + ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right)} \\tag{3} \\end{equation*} \\begin{equation*} \\sigma_N = \\sqrt{1 + ln\\left(\\frac{\\sigma_L^2}{\\mu_L^2}\\right)} \\tag{3} \\end{equation*} De esta forma, hallamos \\sigma_N \\sigma_N usando (3) (3) , y con este valor encontramos \\mu_N \\mu_N usando (1) (1) , lo que en python se traduce en: from math import sqrt , log lognormal_mean = 150000000 lognormal_std = 30000000 normal_std = sqrt ( log ( 1 + ( lognormal_std / lognormal_mean ) ** 2 )) normal_mean = log ( lognormal_mean ) - normal_std ** 2 / 2 display ( Markdown ( f \"$\\mu_N$ = {normal_mean:.6f}, $\\sigma_N$ = {normal_std:.6f}\" )) \\mu_N \\mu_N = 18.806535, \\sigma_N \\sigma_N = 0.198042 El desarrollo de estas expresiones se hace con dos objetivos pedag\u00f3gicos: Dar un ejemplo de como escribir ecuaciones en formato \\LaTeX \\LaTeX y, Mostrar como es necesario de vez en cuando recurrir a las matem\u00e1ticas y la estad\u00edstica para utilizar adecuadamente las herramientas. M\u00e1s a\u00fan, igualando las ecuaciones (0) (0) a cero, \\begin{equation*} \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) - \\mu_L = 0 \\\\ \\sqrt{[\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)} - \\sigma_L = 0 \\end{equation*} \\begin{equation*} \\exp\\left(\\mu_N+\\frac{\\sigma_N^2}{2}\\right) - \\mu_L = 0 \\\\ \\sqrt{[\\exp(\\sigma_N^2)-1] \\exp(2\\mu_N+\\sigma_N^2)} - \\sigma_L = 0 \\end{equation*} podr\u00edamos haber obtenido los par\u00e1metros de la normal subyacente utilizando m\u00e9todos num\u00e9ricos como sigue: from math import exp , sqrt from scipy import optimize def fun ( x ): return [ exp ( x [ 0 ] + x [ 1 ] ** 2 / 2 ) - 150000000 , sqrt (( exp ( x [ 1 ] ** 2 ) - 1 ) * exp ( 2 * x [ 0 ] + x [ 1 ] ** 2 )) - 30000000 ] sol = optimize . root ( fun , [ 0 , 0 ], jac = False , method = 'lm' ) display ( Markdown ( f \"$\\mu_N$ = {sol.x[0]:.6f}, $\\sigma_N$ = {sol.x[1]:.6f}\" )) \\mu_N \\mu_N = 18.806535, \\sigma_N \\sigma_N = 0.198042 La simulaci\u00f3n de la distribuci\u00f3n queda como sigue, trials_cost = np . random . lognormal ( normal_mean , normal_std , 10000 ) plt . hist ( trials_cost , bins = 25 ) plt . show () N\u00f3tese en el gr\u00e1fico como la media de la distribuci\u00f3n se corresponde con los 150 millones. Para la simulaci\u00f3n de las distribuciones triangulares no tenemos mayor problema, esta ser\u00eda la simulaci\u00f3n del factor de crecimiento del mercado: growth_factor = np . random . triangular ( 0.02 , 0.03 , 0.06 , 10000 ) plt . hist ( growth_factor , bins = 25 ) plt . show () Y la tasa de crecimiento de la cuota de mercado, share_growth_rate = np . random . triangular ( 0.15 , 0.20 , 0.25 , 10000 ) plt . hist ( share_growth_rate , bins = 25 ) plt . show ()","title":"Configurando las distribuciones para la simulaci\u00f3n"},{"location":"02emulacion_risk.html#modelo-de-simulacion","text":"Ahora tenemos que juntar todo lo anterior para generar un buen n\u00famero de replicas, digamos 10 mil, a partir de las observaciones aleatorias mencionadas arriba. En lo fundamental, se trata de re-escribir el m\u00e9todo est\u00e1tico sustituyendo las valores fijos por las respectivas distribuciones de probabilidad, teniendo cuidado de escribir las replicas utilizando la vectorizaci\u00f3n. Empezamos por la demanda inicial. market_size = np . random . normal ( 2000000 , 400000 , ( 10000 , 1 )) df_market_size = pd . DataFrame ( market_size , columns = [ \"Mercado\" ]) fill = pd . DataFrame ([[ np . nan ]], columns = df_market_size . columns , index = [ - 1 ]) pd . concat ([ df_market_size . head (), fill , df_market_size . tail ()]) . style . format ( '{:,.2f}' ) Mercado 0 1,652,239.64 1 1,969,999.61 2 2,163,194.86 3 2,026,208.19 4 1,508,792.95 -1 nan 9995 2,186,960.44 9996 2,266,746.44 9997 1,612,958.28 9998 1,614,676.92 9999 2,318,227.67 N\u00f3tese la especificaci\u00f3n de la forma como un vector columna, esto es conveniente para las operaciones matriciales. Convertimos los datos a un DataFrame, al igual que arriba, solamente para que aparezca en un formato tabular. La inversi\u00f3n en investigaci\u00f3n y desarrollo ser\u00eda: rd_cost = np . random . uniform ( 600000000 , 800000000 , ( 10000 , 1 )) df_rd_cost = pd . DataFrame ( rd_cost , columns = [ \"I&D\" ]) df_rd_cost . head () . style . format ( '${:,.2f}' ) I&D 0 $789,017,336.24 1 $681,778,711.82 2 $609,999,767.67 3 $741,289,119.26 4 $778,498,962.07 Se utiliza el m\u00e9todo head para que devuelva solamente los primeros 5 valores de la tabla. La inversi\u00f3n en ensayos cl\u00ednicos: trials_cost = np . random . lognormal ( normal_mean , normal_std , ( 10000 , 1 )) df_trials_cost = pd . DataFrame ( trials_cost , columns = [ \"Trials\" ]) df_trials_cost . head () . style . format ( '${:,.2f}' ) Trials 0 $129,832,559.70 1 $155,901,122.92 2 $188,361,209.28 3 $122,215,935.09 4 $117,333,770.31 Para simular tanto el factor de crecimiento del mercado, como la tasa de crecimiento de la cuota de mercado, se deben simular cuatro valores para cada r\u00e9plica, y adem\u00e1s a\u00f1adir un cero inicial para realizar las operaciones vectorizadas. growth_factor = np . random . triangular ( 0.02 , 0.03 , 0.06 , ( 10000 , 4 )) growth_factor = np . hstack (( np . zeros (( 10000 , 1 )), growth_factor )) df_growth_factor = pd . DataFrame ( growth_factor , columns = [ \"f0\" , \"f1\" , \"f2\" , \"f3\" , \"f4\" ]) df_growth_factor . head () . style . format ( '{:.4%}' ) f0 f1 f2 f3 f4 0 0.0000% 2.4764% 3.1657% 3.5671% 3.2335% 1 0.0000% 3.2036% 3.1690% 3.8859% 2.6284% 2 0.0000% 2.9057% 4.9937% 3.1970% 2.5166% 3 0.0000% 3.9681% 2.7311% 2.6351% 5.7171% 4 0.0000% 3.3604% 3.7505% 2.6006% 4.0251% share_growth_rate = np . random . triangular ( 0.15 , 0.20 , 0.25 , ( 10000 , 4 )) share_growth_rate = np . hstack (( np . zeros (( 10000 , 1 )), share_growth_rate )) df_share_growth_rate = pd . DataFrame ( share_growth_rate , columns = [ \"t0\" , \"t1\" , \"t2\" , \"t3\" , \"t4\" ]) df_share_growth_rate . head () . style . format ( '{:.4%}' ) t0 t1 t2 t3 t4 0 0.0000% 20.6200% 23.3980% 22.2926% 21.0754% 1 0.0000% 17.9850% 22.0162% 20.2440% 19.9272% 2 0.0000% 20.1128% 19.4268% 19.5343% 20.7639% 3 0.0000% 20.2069% 18.5348% 18.6056% 21.9466% 4 0.0000% 21.0364% 19.1765% 21.9899% 19.9574% A continuaci\u00f3n, para calcular el crecimiento del mercado utilizando los factores de crecimiento reci\u00e9n generados, utilizamos la misma expresi\u00f3n indicada arriba con el detalle de a\u00f1adir el par\u00e1metro axis = 1 para realizar la multiplicaci\u00f3n fila por fila. market_growth = market_size * ( growth_factor + 1 ) . cumprod ( axis = 1 ) df_market_growth = pd . DataFrame ( market_growth , columns = [ \"M0\" , \"M1\" , \"M2\" , \"M3\" , \"M4\" ]) df_market_growth . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } M0 M1 M2 M3 M4 0 1.652240e+06 1.693156e+06 1.746757e+06 1.809065e+06 1.867560e+06 1 1.970000e+06 2.033111e+06 2.097540e+06 2.179049e+06 2.236324e+06 2 2.163195e+06 2.226050e+06 2.337212e+06 2.411933e+06 2.472632e+06 3 2.026208e+06 2.106610e+06 2.164143e+06 2.221170e+06 2.348157e+06 4 1.508793e+06 1.559495e+06 1.617983e+06 1.660061e+06 1.726880e+06 Para realizar la simulaci\u00f3n del crecimiento de la cuota de mercado creamos antes un vector columna con los valores de la cuota de mercado inicial. market_share = np . tile ( 0.08 , ( 10000 , 1 )) share_growth = market_share * ( share_growth_rate + 1 ) . cumprod ( axis = 1 ) df_share_growth = pd . DataFrame ( share_growth , columns = [ \"Q0\" , \"Q1\" , \"Q2\" , \"Q3\" , \"Q4\" ]) df_share_growth . head () . style . format ( '{:.4%}' ) Q0 Q1 Q2 Q3 Q4 0 8.0000% 9.6496% 11.9074% 14.5619% 17.6309% 1 8.0000% 9.4388% 11.5169% 13.8483% 16.6079% 2 8.0000% 9.6090% 11.4757% 13.7175% 16.5657% 3 8.0000% 9.6166% 11.3990% 13.5198% 16.4869% 4 8.0000% 9.6829% 11.5398% 14.0773% 16.8868% Los c\u00e1lculos de las ventas, ingresos, costos y beneficios se mantienen id\u00e9nticos: sales = market_growth * share_growth annual_revenue = sales * unit_revenue * 12 annual_costs = sales * unit_cost * 12 profit = annual_revenue - annual_costs total_costs = rd_cost + trials_cost df_sales = pd . DataFrame ( sales , columns = [ \"S0\" , \"S1\" , \"S2\" , \"S3\" , \"S4\" ]) df_sales . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } S0 S1 S2 S3 S4 0 132179.171553 163382.784721 207993.551040 263433.900357 329266.919016 1 157599.969101 191901.224300 241570.911766 301762.089695 371406.892945 2 173055.588797 213901.688289 268212.546825 330855.659805 409609.498834 3 162096.654800 202583.236053 246689.751191 300297.779327 387138.942603 4 120703.435851 151004.502944 186711.234225 233692.317113 291615.027497 df_annual_revenue = pd . DataFrame ( annual_revenue , columns = [ \"IA0\" , \"IA1\" , \"IA2\" , \"IA3\" , \"IA4\" ]) df_annual_revenue . head () . style . format ( '${:,.2f}' ) IA0 IA1 IA2 IA3 IA4 0 $206,199,507.62 $254,877,144.16 $324,469,939.62 $410,956,884.56 $513,656,393.66 1 $245,855,951.80 $299,365,909.91 $376,850,622.36 $470,748,859.92 $579,394,752.99 2 $269,966,718.52 $333,686,633.73 $418,411,573.05 $516,134,829.30 $638,990,818.18 3 $252,870,781.49 $316,029,848.24 $384,836,011.86 $468,464,535.75 $603,936,750.46 4 $188,297,359.93 $235,567,024.59 $291,269,525.39 $364,560,014.70 $454,919,442.90 df_annual_costs = pd . DataFrame ( annual_costs , columns = [ \"CA0\" , \"CA1\" , \"CA2\" , \"CA3\" , \"CA4\" ]) df_annual_costs . head () . style . format ( '${:,.2f}' ) CA0 CA1 CA2 CA3 CA4 0 $63,446,002.35 $78,423,736.67 $99,836,904.50 $126,448,272.17 $158,048,121.13 1 $75,647,985.17 $92,112,587.66 $115,954,037.65 $144,845,803.05 $178,275,308.61 2 $83,066,682.62 $102,672,810.38 $128,742,022.48 $158,810,716.71 $196,612,559.44 3 $77,806,394.30 $97,239,953.31 $118,411,080.57 $144,142,934.08 $185,826,692.45 4 $57,937,649.21 $72,482,161.41 $89,621,392.43 $112,172,312.21 $139,975,213.20 El c\u00e1lculo del beneficio neto acumulado solamente requiere de tener cuidado con que las operaciones sean por filas. net_profit = profit . cumsum ( axis = 1 ) - total_costs df_net_profit = pd . DataFrame ( net_profit , columns = [ \"BNA0\" , \"BNA1\" , \"BNA2\" , \"BNA3\" , \"BNA4\" ]) df_net_profit . head () . style . format ( '${:,.2f}' ) BNA0 BNA1 BNA2 BNA3 BNA4 0 $-776,096,390.66 $-599,642,983.16 $-375,009,948.04 $-90,501,335.65 $265,106,936.89 1 $-667,471,868.11 $-460,218,545.86 $-199,321,961.15 $126,581,095.72 $527,700,540.10 2 $-611,460,941.05 $-380,447,117.70 $-90,777,567.13 $266,546,545.46 $708,924,804.20 3 $-688,440,667.17 $-469,650,772.23 $-203,225,840.94 $121,095,760.73 $539,205,818.74 4 $-765,473,021.66 $-602,388,158.48 $-400,740,025.52 $-148,352,323.04 $166,591,906.66 Finalmente, el c\u00e1lculo del valor presente neto para todas las r\u00e9plicas aparte de realizar la suma por filas requiere que se mantengan las dimensiones keepdims = True porque la suma sobre los vectores por defecto aplana el resultado. net_pv = np . pv ( discount_rate , range ( 1 , 6 ), 0 , - profit ) . sum ( axis = 1 , keepdims = True ) - total_costs df_net_pv = pd . DataFrame ( net_pv , columns = [ \"VPneto\" ]) df_net_pv . head () . style . format ( '${:,.2f}' ) VPneto 0 $-33,234,104.37 1 $185,953,329.08 2 $331,877,625.65 3 $188,484,931.84 4 $-99,772,092.68 Ahora podemos tener la distribuci\u00f3n del valor presente neto del proyecto. plt . hist ( net_pv , bins = 25 ) plt . show () Se puede observar que si bien la media est\u00e1 alrededor de los 200 millones de d\u00f3lares existe la posibilidad de tener retornos negativos. Para calcular este porcentaje sacamos provecho que en Python un valor l\u00f3gico verdadero True es equivalente a 1 para las operaciones aritm\u00e9ticas. De esta manera, negative_risk = ( net_pv < 0 ) . mean () display ( Markdown ( f \"Riesgo de retornos negativos = {negative_risk:.2%}\" )) Riesgo de retornos negativos = 18.98% Nos quedan dos preguntas pendientes: * \u00bfCu\u00e1l es la probabilidad de obtener beneficios acumulados netos (positivos) para el tercer a\u00f1o? * \u00bfQu\u00e9 beneficio acumulado m\u00ednimo se obtendr\u00eda en el 5to a\u00f1o con una probabilidad de por lo menos el 90%? ( net_profit [:, 2 ] > 0 ) . mean () 0 . 0913 np . percentile ( net_profit [:, 4 ], 10 ) 175306982 . 56709474","title":"Modelo de Simulaci\u00f3n"}]}